// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model

ROOST_METHOD_HASH=hex2Color_b74d630591
ROOST_METHOD_SIG_HASH=hex2Color_e227804b01

```markdown
Scenario 1: Valid Hex Color Code
Details:
  TestName: convertValidHexColor
  Description: Tests if a valid hex color code is correctly converted to a Color object.
Execution:
  Arrange: Provide a valid hex color code string like "FF5733".
  Act: Call hex2Color with this hex color code.
  Assert: Assert that the returned Color object represents the color with RGB values corresponding to the hex code (R: 255, G: 87, B: 51).
Validation:
  Clarify that the assertion verifies that the Color object has the correct RGB values. This is important as it confirms that the method accurately parses hex color string inputs into their respective colors.

Scenario 2: Null Input
Details:
  TestName: convertNullInputToColor
  Description: Tests that passing a null input returns null.
Execution:
  Arrange: Set input string to null.
  Act: Call hex2Color with the null input.
  Assert: Assert that the result is null.
Validation:
  Clarify that the assertion aims to verify that the method returns null for null input, adhering to the method's specification of handling null inputs gracefully.

Scenario 3: Invalid Length Hex Code
Details:
  TestName: convertInvalidLengthHex
  Description: Tests that a hex code with length other than 6 characters results in an error or specific behavior.
Execution:
  Arrange: Provide a hex string with incorrect length, e.g., "123".
  Act: Try calling hex2Color and handle potential exceptions or invalid outcomes.
  Assert: Depending on implementation choices, assert an exception is thrown or check for a null/invalid output.
Validation:
  Clarify the assertion that verifies handling of invalid input lengths, which is vital for maintaining robustness against malformed inputs.

Scenario 4: Invalid Characters in Hex Code
Details:
  TestName: convertHexWithInvalidCharacters
  Description: Checks how the method handles hex codes containing characters outside the hexadecimal range (0-9, A-F).
Execution:
  Arrange: Provide a string with invalid characters, such as "ZZZYYY".
  Act: Try calling hex2Color and handle potential errors or invalid conversions.
  Assert: Depending on the method's error handling, either check for an exception or verify that the output is null or invalid.
Validation:
  Illustrate that the test checks for resilience against non-hexadecimal characters, ensuring the method correctly validates and handles input strings.

Scenario 5: Edge Case with Lowercase Hex Code
Details:
  TestName: convertLowercaseHexColor
  Description: Verifies that the method can handle hex codes presented in lowercase letters properly.
Execution:
  Arrange: Provide a valid lowercase hex color code such as "ff5733".
  Act: Call hex2Color with this hex color code.
  Assert: Assert that the returned Color object has the RGB values (R: 255, G: 87, B: 51).
Validation:
  Explain that the assertion checks conversion accuracy irrespective of character case in hex code. Ensuring the method is case-insensitive with respect to input enhances usability.

Scenario 6: Higher Boundary Values in Hex Code
Details:
  TestName: convertBoundaryValueHexColor
  Description: Verify the method's ability to accurately convert high boundary hex values.
Execution:
  Arrange: Use a maximum value hex color code such as "FFFFFF".
  Act: Call hex2Color with this hex color code.
  Assert: Validate that the resulting Color object's RGB is (R: 255, G: 255, B: 255).
Validation:
  Ensure that the test examines the method's accuracy with maximum values, which is crucial for validating the full range of color spectrum handling.
```
*/

// ********RoostGPT********

package com.houarizegai.calculator.util;

import java.awt.Color;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import java.awt.*;
import java.util.Optional;

public class ColorUtilHex2ColorTest {

	@Test
	@Tag("valid")
	public void convertValidHexColor() {
		String hexColor = "FF5733";
		Color expectedColor = new Color(255, 87, 51);
		Color actualColor = ColorUtil.hex2Color(hexColor);
		assertEquals(expectedColor, actualColor, "Should convert hex to correct Color object");
	}

	@Test
	@Tag("invalid")
	public void convertNullInputToColor() {
		String hexColor = null;
		Color actualColor = ColorUtil.hex2Color(hexColor);
		assertNull(actualColor, "Should return null for null input");
	}

	@Test
	@Tag("invalid")
	public void convertInvalidLengthHex() {
		String hexColor = "123";
		Exception exception = assertThrows(IllegalArgumentException.class, () -> ColorUtil.hex2Color(hexColor));
		assertTrue(exception.getMessage().contains("invalid length"), "Expected exception for invalid hex length");
	}

	@Test
	@Tag("invalid")
	public void convertHexWithInvalidCharacters() {
		String hexColor = "ZZZYYY";
		assertThrows(NumberFormatException.class, () -> ColorUtil.hex2Color(hexColor),
				"Should throw NumberFormatException for non-hexadecimal characters");
	}

	@Test
	@Tag("valid")
	public void convertLowercaseHexColor() {
		String hexColor = "ff5733";
		Color expectedColor = new Color(255, 87, 51);
		Color actualColor = ColorUtil.hex2Color(hexColor);
		assertEquals(expectedColor, actualColor, "Should correctly handle lowercase hex codes");
	}

	@Test
	@Tag("boundary")
	public void convertBoundaryValueHexColor() {
		String hexColor = "FFFFFF";
		Color expectedColor = new Color(255, 255, 255);
		Color actualColor = ColorUtil.hex2Color(hexColor);
		assertEquals(expectedColor, actualColor, "Should correctly convert boundary hex values to Color object");
	}

}