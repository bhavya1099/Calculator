// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model

ROOST_METHOD_HASH=getThemes_8aeff0c72b
ROOST_METHOD_SIG_HASH=getThemes_1ad0f9f985

Scenario 1: Verify that getThemes returns an empty list if no themes are set

Details:
  TestName: testGetThemesReturnsEmptyList
  Description: This test checks if the getThemes method returns an empty list when no themes have been added to the ThemeList.
Execution:
  Arrange: Initialize a ThemeList instance and ensure no themes are set.
  Act: Call the getThemes method on the ThemeList instance.
  Assert: Assert that the returned list is empty.
Validation:
  Clarification: The test asserts that the size of the returned list is 0.
  Significance: This test ensures that the getThemes method correctly handles situations where no themes have been initialized, which is crucial for maintaining correct behavior in scenarios where the theme setup is optional or incremental.

Scenario 2: Verify that getThemes returns the correct list of themes after setting them

Details:
  TestName: testGetThemesReturnsCorrectThemes
  Description: This test checks if the getThemes method accurately returns a list of themes after they have been explicitly set.
Execution:
  Arrange: Initialize a ThemeList instance and set a predefined list of themes using the setThemes method.
  Act: Retrieve the themes using getThemes.
  Assert: Assert that the returned themes match the initial list set in the ThemeList.
Validation:
  Clarification: The test asserts that the list returned by getThemes is equal to the list set by setThemes.
  Significance: This test verifies that getThemes properly reflects changes after themes have been set, which is fundamental for accurately displaying or using the themes in the application.

Scenario 3: Verify the immutability of the list returned by getThemes

Details:
  TestName: testGetThemesListImmutability
  Description: This test checks if the list returned by the getThemes method is immutable.
Execution:
  Arrange: Initialize a ThemeList instance and set a list of themes.
  Act: Attempt to modify the list returned by the getThemes method by adding a new theme to it.
  Assert: Catch UnsupportedOperationException to ensure immutability.
Validation:
  Clarification: The test checks that modifying the returned list directly throws an UnsupportedOperationException.
  Significance: Ensuring the returned list is immutable prevents accidental modifications that could lead to inconsistent states within the application, enhancing the robustness of coding using the ThemeList.

Scenario 4: Verify that subsequent modifications to the theme list do not affect the result of getThemes

Details:
  TestName: testGetThemesIndependenceFromInternalState
  Description: This test ensures that any changes made to the internal list of the ThemeList after calling getThemes do not affect the originally retrieved list.
Execution:
  Arrange: Initialize a ThemeList, set initial themes, and retrieve them using getThemes.
  Act: Add more themes to the ThemeList after retrieving the list.
  Assert: Assert that the originally retrieved themes list does not reflect the newly added themes.
Validation:
  Clarification: This test asserts that the list retrieved from getThemes does not change even if the internal state of ThemeList changes.
  Significance: This test ensures the integrity and snapshot nature of the themes list at the time of calling getThemes, which is vital for preventing unexpected behavior in concurrent or multi-step scenarios.
*/

// ********RoostGPT********

package com.houarizegai.calculator.theme.properties;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.junit.jupiter.api.*;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

class ThemeListGetThemesTest {

	private ThemeList themeList;

	@BeforeEach
	void setUp() {
		themeList = new ThemeList();
	}

	@Test
	@Tag("valid")
	public void testGetThemesReturnsEmptyList() {
		assertTrue(themeList.getThemes().isEmpty());
	}

	@Test
	@Tag("integration")
	public void testGetThemesReturnsCorrectThemes() {
		List<Theme> themes = new ArrayList<>();
		Theme theme = new Theme();
		theme.setName("Dark");
		theme.setApplicationBackground("#000000");
		theme.setTextColor("#FFFFFF");
		theme.setBtnEqualTextColor("#FFCC00");
		theme.setOperatorBackground("#333333");
		theme.setNumbersBackground("#444444");
		theme.setBtnEqualBackground("#666666");
		themes.add(theme);
		themeList.setThemes(themes);

		List<Theme> fetchedThemes = themeList.getThemes();
		assertEquals(themes, fetchedThemes);
	}

	@Test
	@Tag("boundary")
	public void testGetThemesListImmutability() {
		List<Theme> themes = new ArrayList<>();
		Theme theme = new Theme();
		theme.setName("Light");
		themes.add(theme);
		themeList.setThemes(themes);
		List<Theme> fetchedThemes = themeList.getThemes();
		assertThrows(UnsupportedOperationException.class, () -> fetchedThemes.add(new Theme()));
	}

	@Test
	@Tag("valid")
	public void testGetThemesIndependenceFromInternalState() {
		List<Theme> initialThemes = new ArrayList<>();
		Theme theme = new Theme();
		theme.setName("Classic");
		initialThemes.add(theme);
		themeList.setThemes(initialThemes);
		List<Theme> fetchedThemes = themeList.getThemes();
		// Modify the theme list after fetching
		Theme newTheme = new Theme();
		newTheme.setName("Modern");
		themeList.getThemes().add(newTheme);
		assertEquals(1, fetchedThemes.size()); // Should not reflect new changes
	}

}