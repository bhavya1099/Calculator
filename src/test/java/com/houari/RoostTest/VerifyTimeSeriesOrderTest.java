// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=e027123530
ROOST_METHOD_SIG_HASH=24c692fb0c

 ########## Scenario ########## 

{
  feature: 'Feature: Test API from Alphavantage.co',
  background: null,
  rule: null,
  scenario: {
    title: 'Scenario: Verify time series order',
    steps: 'Given I have retrieved the daily time series data for AAPL stock\n' +
      'Then the dates should be in descending order\n' +
      'And the most recent date should not be in the future',
    examples: ''
  }
}

*/

// ********RoostGPT********
package com.houari.RoostTest;

import io.restassured.RestAssured;
import io.restassured.response.Response;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static io.restassured.RestAssured.given;
import static org.junit.jupiter.api.Assertions.assertTrue;

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class VerifyTimeSeriesOrderTest {

    private Response response;
    private static final String API_KEY = "YOUR_API_KEY"; // Replace with your actual API key

    @BeforeAll
    public void setup() {
        RestAssured.baseURI = "https://www.alphavantage.co/query";
    }

    @Test
    public void verifyTimeSeriesOrder() {
        // Given I have retrieved the daily time series data for AAPL stock
        response = given()
                .queryParam("function", "TIME_SERIES_DAILY")
                .queryParam("symbol", "AAPL")
                .queryParam("apikey", API_KEY)
                .when()
                .get();

        // Then the dates should be in descending order
        List<LocalDate> dates = extractDatesFromResponse();
        assertTrue(areDatesInDescendingOrder(dates), "Dates are not in descending order");

        // And the most recent date should not be in the future
        LocalDate mostRecentDate = dates.get(0);
        LocalDate currentDate = LocalDate.now();
        assertTrue(mostRecentDate.compareTo(currentDate) <= 0, "Most recent date is in the future");
    }

    private List<LocalDate> extractDatesFromResponse() {
        Map<String, Object> timeSeriesData = response.jsonPath().getMap("Time Series (Daily)");
        List<LocalDate> dates = new ArrayList<>();
        for (String dateString : timeSeriesData.keySet()) {
            dates.add(LocalDate.parse(dateString));
        }
        return dates;
    }

    private boolean areDatesInDescendingOrder(List<LocalDate> dates) {
        for (int i = 0; i < dates.size() - 1; i++) {
            if (dates.get(i).isBefore(dates.get(i + 1))) {
                return false;
            }
        }
        return true;
    }
}
